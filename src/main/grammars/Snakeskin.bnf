{
	parserClass="idea.snakeskin.lang.parser.SnakeskinParser"

	extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

	psiClassPrefix="Ss"
	psiImplClassSuffix="Impl"
	psiPackage="idea.snakeskin.lang.psi"
	psiImplPackage="idea.snakeskin.lang.psi.impl"

	elementTypeHolderClass="idea.snakeskin.lang.psi.SsElementTypes"

	elementTypeClass="idea.snakeskin.lang.psi.SsElementType"
	tokenTypeClass="idea.snakeskin.lang.psi.SsTokenType"

	extends(".*Expression")=Expression

	tokens=[
		BRACE_OPEN  = '{'
		BRACE_CLOSE = '}'
		BRACK_OPEN  = '['
		BRACK_CLOSE = ']'
		PAREN_OPEN  = '('
		PAREN_CLOSE = ')'
		COLON       = ':'
		SEMICOLON   = ';'
		COMMA       = ','
		DOT         = '.'
		EQ          = '='
		EQ_EQ       = '=='
		EQ_EQ_EQ    = '==='
		SHARP       = '#'
		EXCLAMATION = '!'
		NOT_EQ      = '!='
		NOT_EQ_EQ   = '!=='
		PLUS        = '+'
		PLUS_PLUS   = '++'
		PLUS_EQ     = '+='
		MINUS       = '-'
		MINUS_MINUS = '--'
		MINUS_EQ    = '-='
		PIPE        = '|'
		PIPE_PIPE   = '||'
		PIPE_EQ     = '|='
		AMP         = '&'
		AMP_AMP     = '&&'
		AMP_EQ      = '&='
		TILDE       = '~'
		LT          = '<'
		LT_EQ       = '<='
		CARET       = '^'
		CARET_EQ    = '^='
		ASTERISK    = '*'
		ASTERISK_EQ = '*='
		SLASH       = '/'
		SLASH_EQ    = '/='
		PERCENT     = '%'
		PERCENT_EQ  = '%='
		GT          = '>'
		GT_EQ       = '>='
		ARROW       = '->'
		FAT_ARROW   = '=>'
		QUESTION    = '?'
		AT          = '@'
		UNDERSCORE  = '_'
		DOLLAR      = '$'
	]
}

Snakeskin ::= GlobalScopeStatement*
GlobalScopeStatement ::= GlobalScopeInlineStatement
	| EvalBlockStatement
	| TemplateStatement
	| ExternalBlockStatement
	| COMMENT_BLOCK

LocalScopeStatement ::= FunctionalScopeStatement
	| InternalBlockStatement

FunctionalScopeStatement ::= LocalScopeInlineStatement
	| ConditionalStatement
	| SwitchStatement
	| LoopStatement
	| IteratorStatement
	| TryCatchStatement
	| COMMENT_BLOCK

GlobalScopeInlineStatement ::= GlobalScopeInlineDeclarationStatement EOS
GlobalScopeInlineDeclarationStatement ::= VariableStatement
	| GlobalVariableStatement
	| NamespaceStatement
	| IncludeStatement
	| VoidStatement

LocalScopeInlineStatement ::= LocalScopeInlineDeclarationStatement EOS
LocalScopeInlineDeclarationStatement ::= VariableStatement
	| ConstStatement
	| OutputStatement
	| VoidStatement

// Variables
VariableStatement ::= (DeclarationStart var | ':') VariableDeclarationsList
VariableDeclarationsList ::= VariableDeclaration (',' VariableDeclaration)*
VariableDeclaration ::= IDENTIFIER ('=' Expression)?

// Global variables
GlobalVariableStatement ::= DeclarationStart global? GlobalVariableDeclarationsList
GlobalVariableDeclarationsList ::= GlobalVariableDeclaration (',' GlobalVariableDeclaration)*
GlobalVariableDeclaration ::= GlobalDeclarationIdentifier ('=' Expression)?
GlobalDeclarationIdentifier ::= ('@' '@')? (IDENTIFIER | '[' Expression ']')
GlobalIdentifier ::= '@' '@' (IDENTIFIER | '[' Expression ']')

// Const
ConstStatement ::= DeclarationStart const? ConstDeclaration '?'?
ConstDeclaration ::= IDENTIFIER '=' Expression

// Namespace
NamespaceStatement ::= DeclarationStart namespace QualifiedIdentifier

// Include
IncludeStatement ::= DeclarationStart include Expression RenderAsExpression?
RenderAsExpression ::= as (interface | placeholder)

// Output
OutputStatement ::= DeclarationStart output Expression | '{' Expression '}'

// Void
VoidStatement ::= (DeclarationStart void | '?') Expression

// Template
TemplateStatement ::= DeclarationStart TemplateDeclarationStatement EOS BlockBodyStatement?
TemplateDeclarationStatement ::= async? TemplateType '*'? QualifiedIdentifier TemplateDeclarationTail?
TemplateDeclarationTail ::= Arguments TemplateInheritance?
TemplateInheritance ::= extends QualifiedIdentifier
TemplateType ::= template | interface | placeholder
BlockBodyStatement ::= INDENT BlockBody DEDENT
BlockBody ::= LocalScopeStatement*

// Blocks
InternalBlockStatement ::= DeclarationStart InternalBlockDeclarationStatement EOS BlockBodyStatement?
InternalBlockDeclarationStatement ::= block IDENTIFIER BlockDeclarationTail?
ExternalBlockStatement ::= DeclarationStart ExternalBlockDeclarationStatement EOS BlockBodyStatement?
ExternalBlockDeclarationStatement ::= block IDENTIFIER '->' IDENTIFIER BlockDeclarationTail?
BlockDeclarationTail ::= Arguments BlockSelfCall?
BlockSelfCall ::=  ('=>' Expression)

// Eval&Head
EvalBlockStatement ::= DeclarationStart (eval | head) EOS FunctionalBlockBodyStatement?
FunctionalBlockBodyStatement ::= INDENT FunctionalScopeStatement+ DEDENT

// Conditionals
ConditionalStatement ::= MainConditionalStatement SecondaryConditionalStatement* DefaultConditionalStatement?
MainConditionalStatement ::= DeclarationStart (if | unless) Expression EOS FunctionalBlockBodyStatement?
SecondaryConditionalStatement ::= DeclarationStart else (if | unless) Expression EOS FunctionalBlockBodyStatement?
DefaultConditionalStatement ::= DeclarationStart else EOS FunctionalBlockBodyStatement?

SwitchStatement ::= DeclarationStart switch Expression EOS SwitchBodyStatement?
SwitchBodyStatement ::= INDENT CaseStatement+ DefaultStatement? DEDENT
CaseStatement ::= (DeclarationStart case | '>') Expression EOS FunctionalBlockBodyStatement?
DefaultStatement ::= DeclarationStart default EOS FunctionalBlockBodyStatement?

// Loops
LoopStatement ::= ForLoopStatement
	| ForInLoopStatement
	| WhileLoopStatement
	| DoWhileLoopStatement

ForLoopStatement ::= DeclarationStart for Expression ';' Expression ';' Expression EOS LoopBodyStatement?
ForInLoopStatement ::= DeclarationStart for (var | const | global | ':' | '-') IDENTIFIER in Expression EOS LoopBodyStatement?
WhileLoopStatement ::= DeclarationStart while Expression EOS LoopBodyStatement?
DoWhileLoopStatement ::= DeclarationStart do EOS LoopBodyStatement? (DeclarationStart while EOS)?

LoopBodyStatement ::= INDENT LoopScopeStatement+ DEDENT
LoopScopeStatement ::= FunctionalScopeStatement | LoopControlStatement
LoopControlStatement ::= DeclarationStart (break | continue)

// Iterators
IteratorStatement ::= DeclarationStart (FOREACH | FORIN) Expression '=>' Parameters EOS LoopBodyStatement?

// try/catch/finally
TryCatchStatement ::= TryStatement CatchFinallyStatemnt?
TryStatement ::= DeclarationStart try EOS FunctionalBlockBodyStatement?
CatchFinallyStatemnt ::= CatchStatement FinallyStatement?
CatchStatement ::= DeclarationStart catch IDENTIFIER EOS FunctionalBlockBodyStatement?
FinallyStatement ::= DeclarationStart finally EOS FunctionalBlockBodyStatement?

// Parameters
Parameters ::= ParameterDeclaration (',' ParameterDeclaration)*
ParameterDeclaration ::= IDENTIFIER

// Arguments
Arguments ::= '(' ArgumentDeclarationsList? ')'
ArgumentDeclarationsList ::= ArgumentDeclaration (',' ArgumentDeclaration)*
ArgumentDeclaration ::= IDENTIFIER ('?' | '!')? ('=' Expression)?

QualifiedIdentifier ::= (IDENTIFIER | '[' Expression ']') QualifiedIdentifierTail*
QualifiedIdentifierTail ::= '.' IDENTIFIER | '[' Expression ']'

DeclarationStart ::= SHARP | MINUS

// Expressions
Expression ::= AssignmentExpression
	| IndexExpression
	| DotExpression
	| RelationExpression
	| EqualityExpression
	| AddGroup
	| BooleanGroup
	| MulGroup
	| UnaryGroup
	| PrimaryGroup

AssignmentExpression ::= Expression '=' Expression { rightAssociative=true }

IndexExpression ::= Expression '[' Expression ']'

DotExpression ::= Expression '.' IDENTIFIER

RelationExpression ::= Expression RelationOperators Expression
RelationOperators ::= '<' | '>' | '<=' | '>='

EqualityExpression ::= Expression EqualityOperators Expression
EqualityOperators ::= '==' | '!=' | '===' | '!=='

private AddGroup ::= PlusExpression | MinusExpression
private BooleanGroup ::= IsNotExpression | XorExpression | AndExpression | OrExpression
private MulGroup ::= MulExpression | DivExpression | RemainderExpression
private UnaryGroup ::= UnaryPlusExpression | UnaryMinusExpression
private PrimaryGroup ::= LiteralExpression
	| ArrayLiteralExpression
	| ObjectLiteralExpression
	| ParenthesesExpression

PlusExpression ::= Expression '+' Expression
MinusExpression ::= Expression '-' Expression

IsNotExpression ::= '!' Expression
XorExpression ::= Expression '^' Expression
AndExpression ::= Expression '&&' Expression
OrExpression ::= Expression '||' Expression

MulExpression ::= Expression '*' Expression
DivExpression ::= Expression '/' Expression
RemainderExpression ::= Expression '%' Expression

UnaryPlusExpression ::= '+' Expression
UnaryMinusExpression ::= '-' Expression

LiteralExpression ::= NULL_LITERAL
	| UNDEFINED_LITERAL
	| BOOLEAN_LITERAL
	| STRING_LITERAL
	| NUMERIC_LITERAL
	| IDENTIFIER
	| GlobalIdentifier

ArrayLiteralExpression ::= '[' ElementsList ']'
ElementsList ::= Expression (',' Expression)*

ObjectLiteralExpression ::= '{' PropertyAssignmentExpression '}'
PropertyAssignmentExpression ::= PropertyName ':' Expression
PropertyName ::= IDENTIFIER | STRING_LITERAL | NUMERIC_LITERAL

ParenthesesExpression ::= '(' Expression ')'
