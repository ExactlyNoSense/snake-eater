{
	parserClass="idea.snakeskin.lang.parser.SnakeskinParser"

	extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

	psiClassPrefix="Ss"
	psiImplClassSuffix="Impl"
	psiPackage="idea.snakeskin.lang.psi"
	psiImplPackage="idea.snakeskin.lang.psi.impl"

	elementTypeHolderClass="idea.snakeskin.lang.psi.SsElementTypes"

	elementTypeClass="idea.snakeskin.lang.psi.SsElementType"
	tokenTypeClass="idea.snakeskin.lang.psi.SsTokenType"

	extends(".*Expression")=Expression

	tokens=[
		BRACE_OPEN  = '{'
		BRACE_CLOSE = '}'
		BRACK_OPEN  = '['
		BRACK_CLOSE = ']'
		PAREN_OPEN  = '('
		PAREN_CLOSE = ')'
		COLON       = ':'
		SEMICOLON   = ';'
		COMMA       = ','
		DOT         = '.'
		EQ          = '='
		EQ_EQ       = '=='
		EQ_EQ_EQ    = '==='
		SHARP       = '#'
		EXCLAMATION = '!'
		NOT_EQ      = '!='
		NOT_EQ_EQ   = '!=='
		PLUS        = '+'
		PLUS_PLUS   = '++'
		PLUS_EQ     = '+='
		MINUS       = '-'
		MINUS_MINUS = '--'
		MINUS_EQ    = '-='
		PIPE        = '|'
		PIPE_PIPE   = '||'
		PIPE_EQ     = '|='
		AMP         = '&'
		AMP_AMP     = '&&'
		AMP_EQ      = '&='
		TILDE       = '~'
		LT          = '<'
		LT_EQ       = '<='
		CARET       = '^'
		CARET_EQ    = '^='
		ASTERISK    = '*'
		ASTERISK_EQ = '*='
		SLASH       = '/'
		SLASH_EQ    = '/='
		PERCENT     = '%'
		PERCENT_EQ  = '%='
		GT          = '>'
		GT_EQ       = '>='
		ARROW       = '->'
		FAT_ARROW   = '=>'
		QUESTION    = '?'
		AT          = '@'
		UNDERSCORE  = '_'
		DOLLAR      = '$'
		AT_BRACK    = '@['
		AT_AT_BACK  = '@@['
		BRACE_OPEN_OPEN = '{{'
		BRACE_CLOSE_CLOSE = '}}'
		LT_LT_EQ    = '<<='
		GT_GT_EQ    = '>>='
		GT_GT_GT_EQ = '>>>='
	]
}

Snakeskin ::= GlobalStatement*
GlobalStatement ::= GlobalVerboseStatement | GlobalShortStatement

GlobalVerboseStatement ::= StatementStart (GlobalVerboseInlineStatement EOS | GlobalVerboseBlockStatement)
{ pin = 1 }
GlobalVerboseBlockStatement ::= GlobalBlockHead EOS BlockBody?

GlobalShortStatement ::= GlobalShortInlineStatement EOS

private Statement_recover ::= !EOS
private Body_recover ::= !DEDENT

//////////////////////////////
// GLOBAL INLINE STATEMENTS //
//////////////////////////////
GlobalVerboseInlineStatement ::= VerboseVariableStatement
	| DecoratorStatement
	| GlobalVariableStatement
	| NamespaceStatement
	| IncludeStatement
	| ImportStatement
	| VerboseVoidStatement
{ recoverWhile = Statement_recover}

GlobalShortInlineStatement ::= ShortVariableStatement | ShortVoidStatement
{ recoverWhile = Statement_recover }


/////////////////////////////
// GLOBAL BLOCK STATEMENTS //
/////////////////////////////
GlobalBlockHead ::= HeadOrEvalHeadStatement
	| ExternalBlockHeadStatement
	| TemplateHeadStatement
{ recoverWhile = Statement_recover }


BlockBody ::= INDENT BodyStatements DEDENT
{ pin = 1 }
BodyStatements ::= BodyStatement+
{ recoverWhile = Body_recover }
BodyStatement ::= VerboseStatement
	| ShortStatement
	| XmlStatement
	| TemplateTextStatement
	| COMMENT_BLOCK

VerboseStatement ::= StatementStart (VerboseInlineStatement EOS | VerboseBlockStatement)
{ pin = 1 }
VerboseInlineStatement ::= VerboseVariableStatement
	| ConstStatement
	| VerboseOutputStatement
	| VerboseVoidStatement
	| ThrowStatement
	| DoctypeStatement
	| SuperStatement
{ recoverWhile = Statement_recover }

VerboseBlockStatement ::= BlockStatement
	| ConditionalStatement
	| SwitchStatement
	| LoopStatement
	| IteratorStatement
	| TryCatchStatement
	| VerboseFuncStatement
	| TargetStatement
	| VerbosePutInStatement
	| VerboseCallStatement
	| ReturnStatement
	| WithStatement
	| TagStatement

ShortStatement ::= ShortInlineStatement | ShortBlockStatement
ShortInlineStatement ::= ShortVariableStatement
	| ShortOutputStatement
	| ShortVoidStatement

ShortBlockStatement ::= ShortFuncStatement
	| ShortPutInStatement
	| ShortCallStatement


// Variables
VariableDeclarationsList ::= VariableDeclaration (VariableDeclarationsListTail)*
VariableDeclarationsListTail ::= ',' VariableDeclaration
{ pin = 1 }
VariableDeclaration ::= IDENTIFIER ('=' Expression)?
{ recoverWhile = VariableDeclaration_recover }
private VariableDeclaration_recover ::= !(',' | EOS)

VerboseVariableStatement ::= var VariableDeclarationsList
{ pin = 1 }
ShortVariableStatement ::= ':' VariableDeclarationsList

// Global variables
GlobalVariableStatement ::= global? GlobalVariableDeclarationsList
GlobalVariableDeclarationsList ::= GlobalVariableDeclaration (GlobalVariableDeclarationsListTail)*
GlobalVariableDeclarationsListTail ::= ',' GlobalVariableDeclaration
{ pin = 1 }
GlobalVariableDeclaration ::= GlobalDeclarationIdentifier ('=' Expression)?
{ recoverWhile = GlobalVariableDeclaration_recover }
private GlobalVariableDeclaration_recover ::= !(',' | EOS)
GlobalDeclarationIdentifier ::= GLOBAL_IDENTIFIER | IDENTIFIER | '[' Expression ']' | '@@[' Expression ']'

// Const
ConstStatement ::= const? ConstDeclaration '?'?
ConstDeclaration ::= IDENTIFIER '=' Expression

// Namespace
NamespaceStatement ::= namespace DefinitionQualifiedIdentifier
{ pin = 1 }

// Include
IncludeStatement ::= include Expression RenderAsExpression?
{ pin = 1 }
RenderAsExpression ::= as (interface | placeholder)

// Import
ImportStatement ::= import (ImportClause FromClause | ModuleSpecifier)
{ pin = 1 }
ImportClause ::= CombinedImport
	| DefaultImport
	| NamespaceImport
	| NamedImportsList
CombinedImport ::= DefaultImport ',' (NamespaceImport | NamedImportsList)
DefaultImport ::= IDENTIFIER
NamespaceImport ::= '*' as IDENTIFIER
NamedImportsList ::= '{' NamedImport (NamedImportsListTail)* '}'
NamedImportsListTail ::= ',' NamedImport
{ pin = 1 }
NamedImport ::= IDENTIFIER (as IDENTIFIER)?
{ recoverWhile = NamedImport_recover }
private NamedImport_recover ::= !(',' | '}')
FromClause ::= from ModuleSpecifier

ModuleSpecifier ::= STRING_LITERAL

// Output
VerboseOutputStatement ::= output Expression
ShortOutputStatement ::= '{' Expression '}'

// Void
VerboseVoidStatement ::= void Expression
{ pin = 1 }
ShortVoidStatement ::= '?' Expression

// Super
SuperStatement ::= super

// Throw
ThrowStatement ::= throw Expression

// Doctype
DoctypeStatement ::= doctype IDENTIFIER?

// Decorator
DecoratorStatement ::= ExecutionQualifiedIdentifier '(' ')'

// Template
TemplateHeadStatement ::= async? TemplateType '*'? DefinitionQualifiedIdentifier TemplateDeclarationTail?
{ pin = 2 }
TemplateDeclarationTail ::= Arguments TemplateInheritance?
TemplateInheritance ::= extends QualifiedIdentifier
TemplateType ::= template | interface | placeholder

// Blocks
BlockStatement ::= BlockHeadStatement EOS BlockBody?
BlockHeadStatement ::= block IDENTIFIER BlockHeadTail?
{ pin = 1; recoverWhile = Statement_recover }

ExternalBlockHeadStatement ::= block IDENTIFIER '->' IDENTIFIER BlockHeadTail?
{ pin = 1 }
BlockHeadTail ::= Arguments BlockSelfCall?
BlockSelfCall ::=  ('=>' Expression)

// Eval&Head
HeadOrEvalHeadStatement ::= eval | head

// Conditionals
ConditionalStatement ::= MainConditionalStatement SecondaryConditionalStatement*
MainConditionalStatement ::= MainConditionalHead EOS BlockBody?
MainConditionalHead ::= (if | unless) Expression
{ pin = 1; recoverWhile = Statement_recover }
SecondaryConditionalStatement ::= StatementStart SecondaryConditionalHead EOS BlockBody?
{ pin = 1 }
SecondaryConditionalHead ::= else SecondaryConditionalHeadTail?
{ pin = 1; recoverWhile = Statement_recover }
SecondaryConditionalHeadTail ::= (if | unless) Expression


SwitchStatement ::= SwitchHead EOS SwitchBlockBody?
SwitchHead ::= switch Expression
{ pin = 1; recoverWhile = Statement_recover }
SwitchBlockBody ::= INDENT SwitchBodyStatements DEDENT
{ pin = 1}
SwitchBodyStatements ::= SwitchBodyStatement+
{ recoverWhile = Body_recover }

SwitchBodyStatement ::= SwitchCaseStatement EOS BlockBody?
SwitchCaseStatement ::= VerboseSwitchCaseStatement | ShortSwitchCaseStatement
{ recoverWhile = Statement_recover }

VerboseSwitchCaseStatement ::= StatementStart (SwitchCaseHead | DefaultSwitchCaseHead)
{ pin = 1 }
SwitchCaseHead ::= case Expression
{ pin = 1 }
DefaultSwitchCaseHead ::= default

ShortSwitchCaseStatement ::= '>' Expression
{ pin = 1 }


// Loops
LoopStatement ::= ForLoopStatement
	| WhileLoopStatement
	| DoWhileLoopStatement

ForLoopStatement ::= ForLoopHead EOS LoopBlockBody?
ForLoopHead ::= for (CommonForLoopHead | ForInLoopHead)
{ pin = 1; recoverWhile = Statement_recover }
CommonForLoopHead ::= Expression ';' Expression ';' Expression
ForInLoopHead ::= (var | const | global | ':' | '-') IDENTIFIER in Expression

WhileLoopStatement ::= WhileLoopHead EOS LoopBlockBody?
WhileLoopHead ::= while Expression
{ pin = 1; recoverWhile = Statement_recover }
DoWhileLoopStatement ::= do EOS LoopBlockBody? (StatementStart while Expression EOS)?
{ pin = 1 }

LoopBlockBody ::= INDENT LoopBodyStatements DEDENT
{ pin = 1 }
LoopBodyStatements ::= LoopBodyStatement+
{ recoverWhile = Body_recover }
LoopBodyStatement ::= LoopControlStatement | BodyStatement
LoopControlStatement ::= StatementStart (break | continue)

// Iterators
IteratorStatement ::= IteratorHead EOS LoopBlockBody?
IteratorHead ::= (FOREACH | FORIN) Expression '=>' Parameters
{ pin = 1; recoverWhile = Statement_recover }

// try/catch/finally
TryCatchStatement ::= TryStatement CatchFinallyStatement?
TryStatement ::= TryHead EOS BlockBody?
TryHead ::= try
{ recoverWhile = Statement_recover }
CatchFinallyStatement ::= CatchStatement FinallyStatement?
CatchStatement ::= StatementStart CatchHead EOS BlockBody?
CatchHead ::= catch IDENTIFIER
{ pin = 1; recoverWhile = Statement_recover }
FinallyStatement ::= StatementStart FinallyHead EOS BlockBody?
FinallyHead ::= finally
{ recoverWhile = Statement_recover }

// Function
VerboseFuncStatement ::= VerboseFuncHead EOS BlockBody?
VerboseFuncHead ::= func ArgumentDeclarationsList?
{ pin = 1; recoverWhile = Statement_recover }

ShortFuncStatement ::= ShortFuncHead EOS BlockBody?
ShortFuncHead ::= '(' ')' ['=>' ArgumentDeclarationsList?]
{ pin = 1; recoverWhile = Statement_recover }

// Target
TargetStatement ::= TargetHead EOS CallBlockBody?
TargetHead ::= target Expression [as IDENTIFIER]
{ pin = 1; recoverWhile = Statement_recover }

// PutIn
VerbosePutInStatement ::= VerbosePutInHead EOS BlockBody?
VerbosePutInHead ::= var? PUT_IN QualifiedIdentifier?
{ pin = 2; recoverWhile = Statement_recover }

ShortPutInStatement ::= ShortPutInHead EOS BlockBody?
ShortPutInHead ::= ':' PUT_IN QualifiedIdentifier?
{ pin = 1; recoverWhile = Statement_recover }

SuperShortPutInStatement ::= SuperShortPutInHead EOS BlockBody?
SuperShortPutInHead ::= '*' QualifiedIdentifier?
{ pin = 1; recoverWhile = Statement_recover }

// Call
VerboseCallStatement ::= call Expression EOS CallBlockBody?
ShortCallStatement ::= '+=' Expression EOS CallBlockBody?

CallBlockBody ::= INDENT CallBodyStatements DEDENT
{ pin = 1 }
CallBodyStatements ::= CallBodyStatement+
{ recoverWhile = Body_recover }
CallBodyStatement ::= SuperShortPutInStatement | BodyStatement

// Return
ReturnStatement ::= ReturnHead EOS BlockBody?
ReturnHead ::= return Expression?
{ pin = 1; recoverWhile = Statement_recover }

// With
WithStatement ::= WithHead EOS BlockBody?
WithHead ::= with Expression
{ pin = 1; recoverWhile = Statement_recover }

// Tags
TagStatement ::= TagHead EOS BlockBody?
TagHead ::= tag XmlTagDeclaration? XmlSelector? XmlAttrsList?
{ pin = 1; recoverWhile = Statement_recover }

// Parameters
Parameters ::= ParameterDeclaration (',' ParameterDeclaration)*
ParameterDeclaration ::= IDENTIFIER

// Arguments
Arguments ::= '(' ArgumentDeclarationsList? ')'
{ pin = 1 }
ArgumentDeclarationsList ::= ArgumentDeclaration (ArgumentDeclarationsListTail)*
ArgumentDeclarationsListTail ::= ',' ArgumentDeclaration
{ pin = 1 }
ArgumentDeclaration ::= IdentifierOrWithIdentifier ('?' | '!')? ('=' Expression)?
{ recoverWhile = ArgumentDeclaration_recover }
private ArgumentDeclaration_recover ::= !(')' | ',' | EOS)

// Qualified identifiers
// For template inheritance
QualifiedIdentifier ::= (IdentifierOrWithIdentifier | '[' Expression ']' | '@[' Expression ']') QualifiedIdentifierTail*
// For namespace and template definition
DefinitionQualifiedIdentifier ::= (IDENTIFIER | '[' Expression ']') QualifiedIdentifierTail*
// For template execution
ExecutionQualifiedIdentifier ::= (IdentifierOrWithIdentifier | '@[' Expression ']') QualifiedIdentifierTail*
QualifiedIdentifierTail ::= '.' IDENTIFIER | '[' Expression ']'

StatementStart ::= SHARP | MINUS

// XML
XmlStatement ::= TagDeclarationStart XmlHead EOS BlockBody?
{ pin = 1 }
XmlHead ::= XmlTagDeclaration? XmlSelector? XmlAttrsList?
{ recoverWhile = Statement_recover }
XmlTagDeclaration ::= TAG_NAME | '?'
XmlSelector ::= CLASS_SELECTOR* ID_SELECTOR? CLASS_SELECTOR*

XmlAttrsList ::= XmlAttrDeclaration XmlAttrsListTail*
XmlAttrsListTail ::= '|' XmlAttrDeclaration
{ pin = 1 }
XmlAttrDeclaration ::= (ATTR_NAME | TAG_NAME) ['=' ATTR_VALUE?]
{ recoverWhile = XmlAttrDeclaration_recover }
private XmlAttrDeclaration_recover ::= !('|' | EOS)

TagDeclarationStart ::= LT

// Template text
TemplateTextStatement ::= TEMPLATE_TEXT? (TemplateInclusion TEMPLATE_TEXT?)* EOS
TemplateInclusion ::= TemplateOutputStatement | TemplateInterpolationStatement
TemplateOutputStatement ::= '{' Expression '}'
TemplateInterpolationStatement ::= '{{' TEMPLATE_INTERPOLATION '}}'

// Expressions
Expression ::= AssignmentExpression
	| AssignmentOperatorExpression
	| RelationExpression
	| EqualityExpression
	| AddGroup
	| BooleanGroup
	| MulGroup
	| BitGroup
	| UnaryGroup
	| TernaryExpression
	| MemberExpression

AssignmentExpression ::= Expression '=' Expression { rightAssociative = true }

AssignmentOperatorExpression ::= Expression AssignmentOperator Expression { rightAssociative = true }
AssignmentOperator ::= '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '>>>='

RelationExpression ::= Expression RelationOperators Expression
RelationOperators ::= '<' | '>' | '<=' | '>='

EqualityExpression ::= Expression EqualityOperators Expression
EqualityOperators ::= '==' | '!=' | '===' | '!=='

private AddGroup ::= PlusExpression | MinusExpression
private BooleanGroup ::= IsNotExpression | XorExpression | AndExpression | OrExpression
private MulGroup ::= MulExpression | DivExpression | RemainderExpression
private BitGroup ::= BitAndExpression | BitOrExpression | BitXorExpression
private UnaryGroup ::= UnaryPlusExpression | UnaryMinusExpression
private PrimaryGroup ::= LiteralExpression
	| ArrayLiteralExpression
	| ObjectLiteralExpression
	| ParenthesesExpression
	| IdentifierGroup

PlusExpression ::= Expression '+' Expression
MinusExpression ::= Expression '-' Expression

IsNotExpression ::= '!' Expression
XorExpression ::= Expression '^' Expression
AndExpression ::= Expression '&&' Expression
OrExpression ::= Expression '||' Expression

MulExpression ::= Expression '*' Expression
DivExpression ::= Expression '/' Expression
RemainderExpression ::= Expression '%' Expression

BitAndExpression ::= Expression '&' Expression
BitOrExpression ::= Expression '|' Expression
BitXorExpression ::= Expression '^' Expression

UnaryPlusExpression ::= '+' Expression
UnaryMinusExpression ::= '-' Expression

LiteralExpression ::= NULL_LITERAL
	| UNDEFINED_LITERAL
	| BOOLEAN_LITERAL
	| STRING_LITERAL
	| NUMERIC_LITERAL

IdentifierGroup ::= GLOBAL_IDENTIFIER
 | '@@[' Expression ']'
 | WITH_IDENTIFIER
 | '@[' Expression ']'
 | IDENTIFIER
IdentifierOrWithIdentifier ::= IDENTIFIER | WITH_IDENTIFIER

ArrayLiteralExpression ::= '[' ElementsList ']'
ElementsList ::= Expression (',' Expression)*

ObjectLiteralExpression ::= '{' PropertyAssignment '}'
PropertyAssignment ::= PropertyName ':' Expression
PropertyName ::= IDENTIFIER | STRING_LITERAL | NUMERIC_LITERAL

ParenthesesExpression ::= '(' Expression ')'

MemberExpression ::= PrimaryGroup MemberExpressionTail?
MemberExpressionTail ::= ('[' Expression ']' | '.' IDENTIFIER | CallArguments) MemberExpressionTail?
CallArguments ::= '(' [Expression (',' Expression)*] ')'

TernaryExpression ::= Expression '?' Expression ':' Expression
