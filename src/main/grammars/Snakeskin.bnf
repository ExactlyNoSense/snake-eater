{
	parserClass="idea.snakeskin.lang.parser.SnakeskinParser"

	extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

	psiClassPrefix="Ss"
	psiImplClassSuffix="Impl"
	psiPackage="idea.snakeskin.lang.psi"
	psiImplPackage="idea.snakeskin.lang.psi.impl"

	elementTypeHolderClass="idea.snakeskin.lang.psi.SsElementTypes"

	elementTypeClass="idea.snakeskin.lang.psi.SsElementType"
	tokenTypeClass="idea.snakeskin.lang.psi.SsTokenType"

	extends(".*Expression")=Expression

	tokens=[
		BRACE_OPEN  = '{'
		BRACE_CLOSE = '}'
		BRACK_OPEN  = '['
		BRACK_CLOSE = ']'
		PAREN_OPEN  = '('
		PAREN_CLOSE = ')'
		COLON       = ':'
		SEMICOLON   = ';'
		COMMA       = ','
		DOT         = '.'
		EQ          = '='
		EQ_EQ       = '=='
		EQ_EQ_EQ    = '==='
		SHARP       = '#'
		EXCLAMATION = '!'
		NOT_EQ      = '!='
		NOT_EQ_EQ   = '!=='
		PLUS        = '+'
		PLUS_PLUS   = '++'
		PLUS_EQ     = '+='
		MINUS       = '-'
		MINUS_MINUS = '--'
		MINUS_EQ    = '-='
		PIPE        = '|'
		PIPE_PIPE   = '||'
		PIPE_EQ     = '|='
		AMP         = '&'
		AMP_AMP     = '&&'
		AMP_EQ      = '&='
		TILDE       = '~'
		LT          = '<'
		LT_EQ       = '<='
		CARET       = '^'
		CARET_EQ    = '^='
		ASTERISK    = '*'
		ASTERISK_EQ = '*='
		SLASH       = '/'
		SLASH_EQ    = '/='
		PERCENT     = '%'
		PERCENT_EQ  = '%='
		GT          = '>'
		GT_EQ       = '>='
		ARROW       = '->'
		FAT_ARROW   = '=>'
		QUESTION    = '?'
		AT          = '@'
		UNDERSCORE  = '_'
		DOLLAR      = '$'
		AT_BRACK    = '@['
		AT_AT_BACK  = '@@['
		BRACE_OPEN_OPEN = '{{'
		BRACE_CLOSE_CLOSE = '}}'
	]
}

Snakeskin ::= GlobalStatement*

GlobalStatement ::= GlobalVerboseStatement | GlobalShortStatement
GlobalVerboseStatement ::= StatementStart (InnerGlobalVerboseInlineStatement EOS | GlobalVerboseBlockStatement)
{ pin = 1 }
GlobalVerboseBlockStatement ::= GlobalBlockHead EOS BodyBlock?

GlobalShortStatement ::= GlobalShortInlineStatement EOS

private Statement_recover ::= !EOS

//////////////////////////////
// GLOBAL INLINE STATEMENTS //
//////////////////////////////
InnerGlobalVerboseInlineStatement ::= VerboseVariableStatement
	| DecoratorStatement
	| GlobalVariableStatement
	| NamespaceStatement
	| IncludeStatement
	| ImportStatement
	| VerboseVoidStatement
{ recoverWhile = Statement_recover}

GlobalShortInlineStatement ::= ShortVariableStatement
	| ShortVoidStatement


/////////////////////////////
// GLOBAL BLOCK STATEMENTS //
/////////////////////////////
GlobalBlockHead ::= HeadOrEvalHeadStatement
	| ExternalBlockHeadStatement
	| TemplateHeadStatement
{ recoverWhile = Statement_recover }


BodyBlock ::= INDENT BodyStatement+ DEDENT
BodyStatement ::= LocalScopeInlineStatement
	| InternalBlockStatement
	| ConditionalStatement
	| SwitchStatement
	| LoopStatement
	| IteratorStatement
	| TryCatchStatement
	| FuncStatement
	| TargetStatement
	| PutInStatement
	| CallStatement
	| ReturnStatement
	| WithStatement
	| TagStatement
	| XmlStatement
	| TemplateTextStatement
	| COMMENT_BLOCK

LocalScopeInlineStatement ::= LocalScopeInlineDeclarationStatement EOS
LocalScopeInlineDeclarationStatement ::= VariableStatement
	| ConstStatement
	| OutputStatement
	| VoidStatement
	| ThrowStatement
	| DoctypeStatement
	| SuperStatement

// Variables
VariableStatement ::= VarClause VariableDeclarationsList
VarClause ::= DeclarationStart var | ':'
VariableDeclarationsList ::= VariableDeclaration (VariableDeclarationsListTail)*
VariableDeclarationsListTail ::= ',' VariableDeclaration
{ pin = 1 }
VariableDeclaration ::= IDENTIFIER ('=' Expression)?
{ recoverWhile = VariableDeclaration_recover }
private VariableDeclaration_recover ::= !(',' | EOS)

VerboseVariableStatement ::= var VariableDeclarationsList
{ pin = 1 }
ShortVariableStatement ::= ':' VariableDeclarationsList

// Global variables
GlobalVariableStatement ::= global? GlobalVariableDeclarationsList
GlobalVariableDeclarationsList ::= GlobalVariableDeclaration (GlobalVariableDeclarationsListTail)*
GlobalVariableDeclarationsListTail ::= ',' GlobalVariableDeclaration
{ pin = 1 }
GlobalVariableDeclaration ::= GlobalDeclarationIdentifier ('=' Expression)?
{ recoverWhile = GlobalVariableDeclaration_recover }
private GlobalVariableDeclaration_recover ::= !(',' | EOS)
GlobalDeclarationIdentifier ::= GLOBAL_IDENTIFIER | IDENTIFIER | '[' Expression ']' | '@@[' Expression ']'

// Const
ConstStatement ::= DeclarationStart const? ConstDeclaration '?'?
ConstDeclaration ::= IDENTIFIER '=' Expression

// Namespace
NamespaceStatement ::= namespace DefinitionQualifiedIdentifier
{ pin = 1 }

// Include
IncludeStatement ::= include Expression RenderAsExpression?
{ pin = 1 }
RenderAsExpression ::= as (interface | placeholder)

// Import
ImportStatement ::= import (ImportClause FromClause | ModuleSpecifier)
{ pin = 1 }
ImportClause ::= CombinedImport
	| DefaultImport
	| NamespaceImport
	| NamedImportsList
CombinedImport ::= DefaultImport ',' (NamespaceImport | NamedImportsList)
DefaultImport ::= IDENTIFIER
NamespaceImport ::= '*' as IDENTIFIER
NamedImportsList ::= '{' NamedImport (NamedImportsListTail)* '}'
NamedImportsListTail ::= ',' NamedImport
{ pin = 1 }
NamedImport ::= IDENTIFIER (as IDENTIFIER)?
{ recoverWhile = NamedImport_recover }
private NamedImport_recover ::= !(',' | '}')
FromClause ::= from ModuleSpecifier

ModuleSpecifier ::= STRING_LITERAL

// Output
OutputStatement ::= DeclarationStart output Expression | '{' Expression '}'

// Void
VoidStatement ::= (DeclarationStart void | '?') Expression

VerboseVoidStatement ::= void Expression
{ pin = 1 }
ShortVoidStatement ::= '?' Expression

// Super
SuperStatement ::= DeclarationStart super

// Throw
ThrowStatement ::= DeclarationStart throw Expression {
	pin=2
}

// Doctype
DoctypeStatement ::= DeclarationStart doctype IDENTIFIER? {
	pin=2
}

// Decorator
DecoratorStatement ::= ExecutionQualifiedIdentifier '(' ')'

// Template
TemplateHeadStatement ::= async? TemplateType '*'? DefinitionQualifiedIdentifier TemplateDeclarationTail?
{ pin = 2 }
TemplateDeclarationTail ::= Arguments TemplateInheritance?
TemplateInheritance ::= extends QualifiedIdentifier
TemplateType ::= template | interface | placeholder

// Blocks
InternalBlockStatement ::= DeclarationStart InternalBlockDeclarationStatement EOS BodyBlock?
InternalBlockDeclarationStatement ::= block IDENTIFIER BlockDeclarationTail?

ExternalBlockHeadStatement ::= block IDENTIFIER '->' IDENTIFIER BlockDeclarationTail?
{ pin = 1 }
BlockDeclarationTail ::= Arguments BlockSelfCall?
BlockSelfCall ::=  ('=>' Expression)

// Eval&Head
HeadOrEvalHeadStatement ::= eval | head

// Conditionals
ConditionalStatement ::= MainConditionalStatement SecondaryConditionalStatement* DefaultConditionalStatement?
MainConditionalStatement ::= DeclarationStart (if | unless) Expression EOS BodyBlock?
SecondaryConditionalStatement ::= DeclarationStart else (if | unless) Expression EOS BodyBlock?
DefaultConditionalStatement ::= DeclarationStart else EOS BodyBlock?

SwitchStatement ::= DeclarationStart switch Expression EOS SwitchBlock?
SwitchBlock ::= INDENT CaseStatement+ DefaultStatement? DEDENT
CaseStatement ::= (DeclarationStart case | '>') Expression EOS BodyBlock?
DefaultStatement ::= DeclarationStart default EOS BodyBlock?

// Loops
LoopStatement ::= ForLoopStatement
	| ForInLoopStatement
	| WhileLoopStatement
	| DoWhileLoopStatement

ForLoopStatement ::= DeclarationStart for Expression ';' Expression ';' Expression EOS LoopBlock?
ForInLoopStatement ::= DeclarationStart for (var | const | global | ':' | '-') IDENTIFIER in Expression EOS LoopBlock?
WhileLoopStatement ::= DeclarationStart while Expression EOS LoopBlock?
DoWhileLoopStatement ::= DeclarationStart do EOS LoopBlock? (DeclarationStart while EOS)?

LoopBlock ::= INDENT LoopBodyStatement+ DEDENT
LoopBodyStatement ::= BodyStatement | LoopControlStatement
LoopControlStatement ::= DeclarationStart (break | continue)

// Iterators
IteratorStatement ::= DeclarationStart (FOREACH | FORIN) Expression '=>' Parameters EOS LoopBlock?

// try/catch/finally
TryCatchStatement ::= TryStatement CatchFinallyStatemnt?
TryStatement ::= DeclarationStart try EOS BodyBlock?
CatchFinallyStatemnt ::= CatchStatement FinallyStatement?
CatchStatement ::= DeclarationStart catch IDENTIFIER EOS BodyBlock?
FinallyStatement ::= DeclarationStart finally EOS BodyBlock?

// Function
FuncStatement ::= FuncDeclaration EOS BodyBlock?
FuncDeclaration ::= DeclarationStart func ArgumentDeclarationsList? | '(' ')' ['=>' ArgumentDeclarationsList?]

// Target
TargetStatement ::= DeclarationStart target Expression (as IDENTIFIER)? EOS TargetBodyStatement?
TargetBodyStatement ::= INDENT PutInStatement+ DEDENT

// PutIn
PutInStatement ::= ((VarClause | DeclarationStart) PUT_IN | '*') QualifiedIdentifier? EOS BodyBlock?

// Call
CallStatement ::= (DeclarationStart call | '+=') Expression EOS CallBlock?
CallBlock ::= INDENT CallBodyStatement+ DEDENT
CallBodyStatement ::= PutInStatement | BodyStatement

// Return
ReturnStatement ::= DeclarationStart return Expression? EOS BodyBlock?

// With
WithStatement ::= DeclarationStart with Expression EOS BodyBlock?

// Tags
TagStatement ::= DeclarationStart tag XmlTagDeclaration? XmlSelector? XmlAttrsDeclaration? EOS BodyBlock?

// Parameters
Parameters ::= ParameterDeclaration (',' ParameterDeclaration)*
ParameterDeclaration ::= IDENTIFIER

// Arguments
Arguments ::= '(' ArgumentDeclarationsList? ')'
{ pin = 1 }
ArgumentDeclarationsList ::= ArgumentDeclaration (ArgumentDeclarationsListTail)*
ArgumentDeclarationsListTail ::= ',' ArgumentDeclaration
{ pin = 1 }
ArgumentDeclaration ::= IdentifierOrWithIdentifier ('?' | '!')? ('=' Expression)?
{ recoverWhile = ArgumentDeclaration_recover }
private ArgumentDeclaration_recover ::= !(')' | ',' | EOS)

// Qualified identifiers
// For template inheritance
QualifiedIdentifier ::= (IdentifierOrWithIdentifier | '[' Expression ']' | '@[' Expression ']') QualifiedIdentifierTail*
// For namespace and template definition
DefinitionQualifiedIdentifier ::= (IDENTIFIER | '[' Expression ']') QualifiedIdentifierTail*
// For template execution
ExecutionQualifiedIdentifier ::= (IdentifierOrWithIdentifier | '@[' Expression ']') QualifiedIdentifierTail*
QualifiedIdentifierTail ::= '.' IDENTIFIER | '[' Expression ']'

DeclarationStart ::= SHARP | MINUS
StatementStart ::= SHARP | MINUS

// XML
XmlStatement ::= TagDeclarationStart XmlTagDeclaration? XmlSelector? XmlAttrsDeclaration? EOS BodyBlock?
XmlTagDeclaration ::= TAG_NAME | '?'
XmlSelector ::= CLASS_SELECTOR* ID_SELECTOR? CLASS_SELECTOR*
XmlAttrsDeclaration ::= XmlAttrDeclaration ('|' XmlAttrDeclaration)*
XmlAttrDeclaration ::= ATTR_NAME ['=' ATTR_VALUE?]

TagDeclarationStart ::= LT

// Template text
TemplateTextStatement ::= TEMPLATE_TEXT? (TemplateInclusion TEMPLATE_TEXT?)* EOS
TemplateInclusion ::= TemplateOutputStatement | TemplateInterpolationStatement
TemplateOutputStatement ::= '{' Expression '}'
TemplateInterpolationStatement ::= '{{' TEMPLATE_INTERPOLATION '}}'

// Expressions
Expression ::= AssignmentExpression
	| RelationExpression
	| EqualityExpression
	| AddGroup
	| BooleanGroup
	| MulGroup
	| UnaryGroup
	| TernaryExpression
	| MemberExpression

AssignmentExpression ::= Expression '=' Expression { rightAssociative=true }

RelationExpression ::= Expression RelationOperators Expression
RelationOperators ::= '<' | '>' | '<=' | '>='

EqualityExpression ::= Expression EqualityOperators Expression
EqualityOperators ::= '==' | '!=' | '===' | '!=='

private AddGroup ::= PlusExpression | MinusExpression
private BooleanGroup ::= IsNotExpression | XorExpression | AndExpression | OrExpression
private MulGroup ::= MulExpression | DivExpression | RemainderExpression
private UnaryGroup ::= UnaryPlusExpression | UnaryMinusExpression
private PrimaryGroup ::= LiteralExpression
	| ArrayLiteralExpression
	| ObjectLiteralExpression
	| ParenthesesExpression
	| IdentifierGroup

PlusExpression ::= Expression '+' Expression
MinusExpression ::= Expression '-' Expression

IsNotExpression ::= '!' Expression
XorExpression ::= Expression '^' Expression
AndExpression ::= Expression '&&' Expression
OrExpression ::= Expression '||' Expression

MulExpression ::= Expression '*' Expression
DivExpression ::= Expression '/' Expression
RemainderExpression ::= Expression '%' Expression

UnaryPlusExpression ::= '+' Expression
UnaryMinusExpression ::= '-' Expression

LiteralExpression ::= NULL_LITERAL
	| UNDEFINED_LITERAL
	| BOOLEAN_LITERAL
	| STRING_LITERAL
	| NUMERIC_LITERAL

IdentifierGroup ::= GLOBAL_IDENTIFIER
 | '@@[' Expression ']'
 | WITH_IDENTIFIER
 | '@[' Expression ']'
 | IDENTIFIER
IdentifierOrWithIdentifier ::= IDENTIFIER | WITH_IDENTIFIER

ArrayLiteralExpression ::= '[' ElementsList ']'
ElementsList ::= Expression (',' Expression)*

ObjectLiteralExpression ::= '{' PropertyAssignment '}'
PropertyAssignment ::= PropertyName ':' Expression
PropertyName ::= IDENTIFIER | STRING_LITERAL | NUMERIC_LITERAL

ParenthesesExpression ::= '(' Expression ')'

MemberExpression ::= PrimaryGroup MemberExpressionTail?
MemberExpressionTail ::= ('[' Expression ']' | '.' IDENTIFIER | CallArguments) MemberExpressionTail?
CallArguments ::= '(' [Expression (',' Expression)*] ')'

TernaryExpression ::= Expression '?' Expression ':' Expression
