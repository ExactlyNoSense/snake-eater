{
	parserClass="idea.snakeskin.lang.parser.SnakeskinParser"

	extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

	psiClassPrefix="Ss"
	psiImplClassSuffix="Impl"
	psiPackage="idea.snakeskin.lang.psi"
	psiImplPackage="idea.snakeskin.lang.psi.impl"

	elementTypeHolderClass="idea.snakeskin.lang.psi.SsElementTypes"

	elementTypeClass="idea.snakeskin.lang.psi.SsElementType"
	tokenTypeClass="idea.snakeskin.lang.psi.SsTokenType"

	extends(".*Expression")=Expression

	tokens=[
		BRACE_OPEN  = '{'
		BRACE_CLOSE = '}'
		BRACK_OPEN  = '['
		BRACK_CLOSE = ']'
		PAREN_OPEN  = '('
		PAREN_CLOSE = ')'
		COLON       = ':'
		SEMICOLON   = ';'
		COMMA       = ','
		DOT         = '.'
		EQ          = '='
		EQ_EQ       = '=='
		EQ_EQ_EQ    = '==='
		SHARP       = '#'
		EXCLAMATION = '!'
		NOT_EQ      = '!='
		NOT_EQ_EQ   = '!=='
		PLUS        = '+'
		PLUS_PLUS   = '++'
		PLUS_EQ     = '+='
		MINUS       = '-'
		MINUS_MINUS = '--'
		MINUS_EQ    = '-='
		PIPE        = '|'
		PIPE_PIPE   = '||'
		PIPE_EQ     = '|='
		AMP         = '&'
		AMP_AMP     = '&&'
		AMP_EQ      = '&='
		TILDE       = '~'
		LT          = '<'
		LT_EQ       = '<='
		CARET       = '^'
		CARET_EQ    = '^='
		ASTERISK    = '*'
		ASTERISK_EQ = '*='
		SLASH       = '/'
		SLASH_EQ    = '/='
		PERCENT     = '%'
		PERCENT_EQ  = '%='
		GT          = '>'
		GT_EQ       = '>='
		ARROW       = '->'
		FAT_ARROW   = '=>'
		QUESTION    = '?'
		AT          = '@'
		UNDERSCORE  = '_'
		DOLLAR      = '$'
		AT_BRACK    = '@['
		AT_AT_BACK  = '@@['
		BRACE_OPEN_OPEN = '{{'
		BRACE_CLOSE_CLOSE = '}}'
	]
}

Snakeskin ::= GlobalStatement*
GlobalStatement ::= GlobalInlineStatement
	| EvalBlockStatement
	| TemplateStatement
	| ExternalBlockStatement
	| COMMENT_BLOCK

Block ::= INDENT BodyStatement+ DEDENT
BodyStatement ::= LocalScopeInlineStatement
	| InternalBlockStatement
	| ConditionalStatement
	| SwitchStatement
	| LoopStatement
	| IteratorStatement
	| TryCatchStatement
	| FuncStatement
	| TargetStatement
	| PutInStatement
	| CallStatement
	| ReturnStatement
	| WithStatement
	| TagStatement
	| XmlStatement
	| TemplateTextStatement
	| COMMENT_BLOCK

GlobalInlineStatement ::= GlobalScopeInlineDeclarationStatement EOS
GlobalScopeInlineDeclarationStatement ::= VariableStatement
	| GlobalVariableStatement
	| NamespaceStatement
	| IncludeStatement
	| ImportStatement
	| VoidStatement
	| DecoratorStatement

LocalScopeInlineStatement ::= LocalScopeInlineDeclarationStatement EOS
LocalScopeInlineDeclarationStatement ::= VariableStatement
	| ConstStatement
	| OutputStatement
	| VoidStatement
	| ThrowStatement
	| DoctypeStatement
	| SuperStatement

private InlineStatement_recover ::= !EOS

// Variables
VariableStatement ::= VarClause VariableDeclarationsList
VarClause ::= DeclarationStart var | ':'
VariableDeclarationsList ::= VariableDeclaration (',' VariableDeclaration)*
VariableDeclaration ::= IDENTIFIER ('=' Expression)?

// Global variables
GlobalVariableStatement ::= DeclarationStart global? GlobalVariableDeclarationsList
GlobalVariableDeclarationsList ::= GlobalVariableDeclaration (',' GlobalVariableDeclaration)*
GlobalVariableDeclaration ::= GlobalDeclarationIdentifier ('=' Expression)?
GlobalDeclarationIdentifier ::= GLOBAL_IDENTIFIER | IDENTIFIER | '[' Expression ']' | '@@[' Expression ']'

// Const
ConstStatement ::= DeclarationStart const? ConstDeclaration '?'?
ConstDeclaration ::= IDENTIFIER '=' Expression

// Namespace
NamespaceStatement ::= DeclarationStart namespace DefinitionQualifiedIdentifier {
	pin=2
	recoverWhile=InlineStatement_recover
}

// Include
IncludeStatement ::= DeclarationStart include Expression RenderAsExpression?
RenderAsExpression ::= as (interface | placeholder)

// Import
ImportStatement ::= DeclarationStart ImportDeclaration
ImportDeclaration ::= import (ImportClause FromClause | ModuleSpecifier)

ImportClause ::= CombinedImport
	| DefaultImport
	| NamespaceImport
	| NamedImportsList
CombinedImport ::= DefaultImport ',' (NamespaceImport | NamedImportsList)
DefaultImport ::= IDENTIFIER
NamespaceImport ::= '*' as IDENTIFIER
NamedImportsList ::= '{' NamedImport (',' NamedImport)* '}'
NamedImport ::= IDENTIFIER (as IDENTIFIER)?

FromClause ::= from ModuleSpecifier

ModuleSpecifier ::= STRING_LITERAL

// Output
OutputStatement ::= DeclarationStart output Expression | '{' Expression '}'

// Void
VoidStatement ::= (DeclarationStart void | '?') Expression

// Super
SuperStatement ::= DeclarationStart super

// Throw
ThrowStatement ::= DeclarationStart throw Expression

// Doctype
DoctypeStatement ::= DeclarationStart doctype IDENTIFIER?

// Decorator
DecoratorStatement ::= DeclarationStart ExecutionQualifiedIdentifier '(' ')'

// Template
TemplateStatement ::= DeclarationStart TemplateDeclarationStatement EOS Block?
TemplateDeclarationStatement ::= async? TemplateType '*'? DefinitionQualifiedIdentifier TemplateDeclarationTail?
TemplateDeclarationTail ::= Arguments TemplateInheritance?
TemplateInheritance ::= extends QualifiedIdentifier
TemplateType ::= template | interface | placeholder

// Blocks
InternalBlockStatement ::= DeclarationStart InternalBlockDeclarationStatement EOS Block?
InternalBlockDeclarationStatement ::= block IDENTIFIER BlockDeclarationTail?

ExternalBlockStatement ::= DeclarationStart ExternalBlockDeclarationStatement EOS Block?
ExternalBlockDeclarationStatement ::= block IDENTIFIER '->' IDENTIFIER BlockDeclarationTail?
BlockDeclarationTail ::= Arguments BlockSelfCall?
BlockSelfCall ::=  ('=>' Expression)

// Eval&Head
EvalBlockStatement ::= DeclarationStart (eval | head) EOS Block?

// Conditionals
ConditionalStatement ::= MainConditionalStatement SecondaryConditionalStatement* DefaultConditionalStatement?
MainConditionalStatement ::= DeclarationStart (if | unless) Expression EOS Block?
SecondaryConditionalStatement ::= DeclarationStart else (if | unless) Expression EOS Block?
DefaultConditionalStatement ::= DeclarationStart else EOS Block?

SwitchStatement ::= DeclarationStart switch Expression EOS SwitchBlock?
SwitchBlock ::= INDENT CaseStatement+ DefaultStatement? DEDENT
CaseStatement ::= (DeclarationStart case | '>') Expression EOS Block?
DefaultStatement ::= DeclarationStart default EOS Block?

// Loops
LoopStatement ::= ForLoopStatement
	| ForInLoopStatement
	| WhileLoopStatement
	| DoWhileLoopStatement

ForLoopStatement ::= DeclarationStart for Expression ';' Expression ';' Expression EOS LoopBlock?
ForInLoopStatement ::= DeclarationStart for (var | const | global | ':' | '-') IDENTIFIER in Expression EOS LoopBlock?
WhileLoopStatement ::= DeclarationStart while Expression EOS LoopBlock?
DoWhileLoopStatement ::= DeclarationStart do EOS LoopBlock? (DeclarationStart while EOS)?

LoopBlock ::= INDENT LoopBodyStatement+ DEDENT
LoopBodyStatement ::= BodyStatement | LoopControlStatement
LoopControlStatement ::= DeclarationStart (break | continue)

// Iterators
IteratorStatement ::= DeclarationStart (FOREACH | FORIN) Expression '=>' Parameters EOS LoopBlock?

// try/catch/finally
TryCatchStatement ::= TryStatement CatchFinallyStatemnt?
TryStatement ::= DeclarationStart try EOS Block?
CatchFinallyStatemnt ::= CatchStatement FinallyStatement?
CatchStatement ::= DeclarationStart catch IDENTIFIER EOS Block?
FinallyStatement ::= DeclarationStart finally EOS Block?

// Function
FuncStatement ::= FuncDeclaration EOS Block?
FuncDeclaration ::= DeclarationStart func ArgumentDeclarationsList? | '(' ')' ['=>' ArgumentDeclarationsList?]

// Target
TargetStatement ::= DeclarationStart target Expression (as IDENTIFIER)? EOS TargetBodyStatement?
TargetBodyStatement ::= INDENT PutInStatement+ DEDENT

// PutIn
PutInStatement ::= ((VarClause | DeclarationStart) PUT_IN | '*') QualifiedIdentifier? EOS Block?

// Call
CallStatement ::= (DeclarationStart call | '+=') Expression EOS CallBlock?
CallBlock ::= INDENT CallBodyStatement DEDENT
CallBodyStatement ::= PutInStatement+ | BodyStatement+

// Return
ReturnStatement ::= DeclarationStart return Expression? EOS Block?

// With
WithStatement ::= DeclarationStart with Expression EOS Block?

// Tags
TagStatement ::= DeclarationStart tag XmlTagDeclaration? XmlSelector? XmlAttrsDeclaration? EOS Block?

// Parameters
Parameters ::= ParameterDeclaration (',' ParameterDeclaration)*
ParameterDeclaration ::= IDENTIFIER

// Arguments
Arguments ::= '(' ArgumentDeclarationsList? ')'
ArgumentDeclarationsList ::= ArgumentDeclaration (',' ArgumentDeclaration)*
ArgumentDeclaration ::= IdentifierOrWithIdentifier ('?' | '!')? ('=' Expression)?

// Qualified identifiers
// For template inheritance
QualifiedIdentifier ::= (IdentifierOrWithIdentifier | '[' Expression ']' | '@[' Expression ']') QualifiedIdentifierTail*
// For namespace and template definition
DefinitionQualifiedIdentifier ::= (IDENTIFIER | '[' Expression ']') QualifiedIdentifierTail*
// For template execution
ExecutionQualifiedIdentifier ::= (IdentifierOrWithIdentifier | '@[' Expression ']') QualifiedIdentifierTail*
QualifiedIdentifierTail ::= '.' IDENTIFIER | '[' Expression ']'

DeclarationStart ::= SHARP | MINUS

// XML
XmlStatement ::= TagDeclarationStart XmlTagDeclaration? XmlSelector? XmlAttrsDeclaration? EOS Block?
XmlTagDeclaration ::= TAG_NAME | '?'
XmlSelector ::= CLASS_SELECTOR* ID_SELECTOR? CLASS_SELECTOR*
XmlAttrsDeclaration ::= XmlAttrDeclaration ('|' XmlAttrDeclaration)*
XmlAttrDeclaration ::= ATTR_NAME ['=' ATTR_VALUE?]

TagDeclarationStart ::= LT

// Template text
TemplateTextStatement ::= TEMPLATE_TEXT? (TemplateInclusion TEMPLATE_TEXT?)* EOS
TemplateInclusion ::= TemplateOutputStatement | TemplateInterpolationStatement
TemplateOutputStatement ::= '{' Expression '}'
TemplateInterpolationStatement ::= '{{' TEMPLATE_INTERPOLATION '}}'

// Expressions
Expression ::= AssignmentExpression
	| RelationExpression
	| EqualityExpression
	| AddGroup
	| BooleanGroup
	| MulGroup
	| UnaryGroup
	| TernaryExpression
	| MemberExpression

AssignmentExpression ::= Expression '=' Expression { rightAssociative=true }

RelationExpression ::= Expression RelationOperators Expression
RelationOperators ::= '<' | '>' | '<=' | '>='

EqualityExpression ::= Expression EqualityOperators Expression
EqualityOperators ::= '==' | '!=' | '===' | '!=='

private AddGroup ::= PlusExpression | MinusExpression
private BooleanGroup ::= IsNotExpression | XorExpression | AndExpression | OrExpression
private MulGroup ::= MulExpression | DivExpression | RemainderExpression
private UnaryGroup ::= UnaryPlusExpression | UnaryMinusExpression
private PrimaryGroup ::= LiteralExpression
	| ArrayLiteralExpression
	| ObjectLiteralExpression
	| ParenthesesExpression
	| IdentifierGroup

PlusExpression ::= Expression '+' Expression
MinusExpression ::= Expression '-' Expression

IsNotExpression ::= '!' Expression
XorExpression ::= Expression '^' Expression
AndExpression ::= Expression '&&' Expression
OrExpression ::= Expression '||' Expression

MulExpression ::= Expression '*' Expression
DivExpression ::= Expression '/' Expression
RemainderExpression ::= Expression '%' Expression

UnaryPlusExpression ::= '+' Expression
UnaryMinusExpression ::= '-' Expression

LiteralExpression ::= NULL_LITERAL
	| UNDEFINED_LITERAL
	| BOOLEAN_LITERAL
	| STRING_LITERAL
	| NUMERIC_LITERAL

IdentifierGroup ::= GLOBAL_IDENTIFIER
 | '@@[' Expression ']'
 | WITH_IDENTIFIER
 | '@[' Expression ']'
 | IDENTIFIER
IdentifierOrWithIdentifier ::= IDENTIFIER | WITH_IDENTIFIER

ArrayLiteralExpression ::= '[' ElementsList ']'
ElementsList ::= Expression (',' Expression)*

ObjectLiteralExpression ::= '{' PropertyAssignment '}'
PropertyAssignment ::= PropertyName ':' Expression
PropertyName ::= IDENTIFIER | STRING_LITERAL | NUMERIC_LITERAL

ParenthesesExpression ::= '(' Expression ')'

MemberExpression ::= PrimaryGroup MemberExpressionTail?
MemberExpressionTail ::= ('[' Expression ']' | '.' IDENTIFIER | CallArguments) MemberExpressionTail?
CallArguments ::= '(' [Expression (',' Expression)*] ')'

TernaryExpression ::= Expression '?' Expression ':' Expression
