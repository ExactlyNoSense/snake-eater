{
	parserClass="idea.snakeskin.lang.parser.SnakeskinParser"

	extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

	psiClassPrefix="Ss"
	psiImplClassSuffix="Impl"
	psiPackage="idea.snakeskin.lang.psi"
	psiImplPackage="idea.snakeskin.lang.psi.impl"

	elementTypeHolderClass="idea.snakeskin.lang.psi.SsElementTypes"

	elementTypeClass="idea.snakeskin.lang.psi.SsElementType"
	tokenTypeClass="idea.snakeskin.lang.psi.SsTokenType"

	extends(".*Expression")=Expression

	tokens=[
		BRACE_OPEN  = '{'
		BRACE_CLOSE = '}'
		BRACK_OPEN  = '['
		BRACK_CLOSE = ']'
		PAREN_OPEN  = '('
		PAREN_CLOSE = ')'
		COLON       = ':'
		SEMICOLON   = ';'
		COMMA       = ','
		DOT         = '.'
		EQ          = '='
		EQ_EQ       = '=='
		EQ_EQ_EQ    = '==='
		SHARP       = '#'
		EXCLAMATION = '!'
		NOT_EQ      = '!='
		NOT_EQ_EQ   = '!=='
		PLUS        = '+'
		PLUS_PLUS   = '++'
		PLUS_EQ     = '+='
		MINUS       = '-'
		MINUS_MINUS = '--'
		MINUS_EQ    = '-='
		PIPE        = '|'
		PIPE_PIPE   = '||'
		PIPE_EQ     = '|='
		AMP         = '&'
		AMP_AMP     = '&&'
		AMP_EQ      = '&='
		TILDE       = '~'
		LT          = '<'
		LT_EQ       = '<='
		CARET       = '^'
		CARET_EQ    = '^='
		ASTERISK    = '*'
		ASTERISK_EQ = '*='
		SLASH       = '/'
		SLASH_EQ    = '/='
		PERCENT     = '%'
		PERCENT_EQ  = '%='
		GT          = '>'
		GT_EQ       = '>='
		ARROW       = '->'
		FAT_ARROW   = '=>'
		QUESTION    = '?'
		AT          = '@'
		UNDERSCORE  = '_'
		DOLLAR      = '$'
		AT_BRACK    = '@['
		AT_AT_BACK  = '@@['
		BRACE_OPEN_OPEN = '{{'
		BRACE_CLOSE_CLOSE = '}}'
	]
}

Snakeskin ::= GlobalStatement*
GlobalStatement ::= GlobalVerboseStatement | GlobalShortStatement

GlobalVerboseStatement ::= StatementStart (GlobalVerboseInlineStatement EOS | GlobalVerboseBlockStatement)
{ pin = 1 }
GlobalVerboseBlockStatement ::= GlobalBlockHead EOS BlockBody?

GlobalShortStatement ::= GlobalShortInlineStatement EOS

private Statement_recover ::= !EOS
private Body_recover ::= !DEDENT

//////////////////////////////
// GLOBAL INLINE STATEMENTS //
//////////////////////////////
GlobalVerboseInlineStatement ::= VerboseVariableStatement
	| DecoratorStatement
	| GlobalVariableStatement
	| NamespaceStatement
	| IncludeStatement
	| ImportStatement
	| VerboseVoidStatement
{ recoverWhile = Statement_recover}

GlobalShortInlineStatement ::= ShortVariableStatement | ShortVoidStatement
{ recoverWhile = Statement_recover }


/////////////////////////////
// GLOBAL BLOCK STATEMENTS //
/////////////////////////////
GlobalBlockHead ::= HeadOrEvalHeadStatement
	| ExternalBlockHeadStatement
	| TemplateHeadStatement
{ recoverWhile = Statement_recover }


BlockBody ::= INDENT BodyStatements DEDENT
{ pin = 1 }
BodyStatements ::= BodyStatement+
{ recoverWhile = Body_recover }
BodyStatement ::= VerboseStatement
	| ShortStatement
	| XmlStatement
	| TemplateTextStatement
	| COMMENT_BLOCK

VerboseStatement ::= StatementStart (VerboseInlineStatement EOS | VerboseBlockStatement)
{ pin = 1 }
VerboseInlineStatement ::= VerboseVariableStatement
	| ConstStatement
	| VerboseOutputStatement
	| VerboseVoidStatement
	| ThrowStatement
	| DoctypeStatement
	| SuperStatement
{ recoverWhile = Statement_recover }

VerboseBlockStatement ::= BlockStatement
	| ConditionalStatement
	| SwitchStatement
	| LoopStatement
	| IteratorStatement
	| TryCatchStatement
	| FuncStatement
	| TargetStatement
	| VerbosePutInStatement
	| VerboseCallStatement
	| ReturnStatement
	| WithStatement
	| TagStatement

ShortStatement ::= ShortInlineStatement | ShortBlockStatement
ShortInlineStatement ::= ShortVariableStatement
	| ShortOutputStatement
	| ShortVoidStatement

ShortBlockStatement ::= ShortPutInStatement
	| ShortCallStatement


// Variables
VariableDeclarationsList ::= VariableDeclaration (VariableDeclarationsListTail)*
VariableDeclarationsListTail ::= ',' VariableDeclaration
{ pin = 1 }
VariableDeclaration ::= IDENTIFIER ('=' Expression)?
{ recoverWhile = VariableDeclaration_recover }
private VariableDeclaration_recover ::= !(',' | EOS)

VerboseVariableStatement ::= var VariableDeclarationsList
{ pin = 1 }
ShortVariableStatement ::= ':' VariableDeclarationsList

// Global variables
GlobalVariableStatement ::= global? GlobalVariableDeclarationsList
GlobalVariableDeclarationsList ::= GlobalVariableDeclaration (GlobalVariableDeclarationsListTail)*
GlobalVariableDeclarationsListTail ::= ',' GlobalVariableDeclaration
{ pin = 1 }
GlobalVariableDeclaration ::= GlobalDeclarationIdentifier ('=' Expression)?
{ recoverWhile = GlobalVariableDeclaration_recover }
private GlobalVariableDeclaration_recover ::= !(',' | EOS)
GlobalDeclarationIdentifier ::= GLOBAL_IDENTIFIER | IDENTIFIER | '[' Expression ']' | '@@[' Expression ']'

// Const
ConstStatement ::= const? ConstDeclaration '?'?
ConstDeclaration ::= IDENTIFIER '=' Expression

// Namespace
NamespaceStatement ::= namespace DefinitionQualifiedIdentifier
{ pin = 1 }

// Include
IncludeStatement ::= include Expression RenderAsExpression?
{ pin = 1 }
RenderAsExpression ::= as (interface | placeholder)

// Import
ImportStatement ::= import (ImportClause FromClause | ModuleSpecifier)
{ pin = 1 }
ImportClause ::= CombinedImport
	| DefaultImport
	| NamespaceImport
	| NamedImportsList
CombinedImport ::= DefaultImport ',' (NamespaceImport | NamedImportsList)
DefaultImport ::= IDENTIFIER
NamespaceImport ::= '*' as IDENTIFIER
NamedImportsList ::= '{' NamedImport (NamedImportsListTail)* '}'
NamedImportsListTail ::= ',' NamedImport
{ pin = 1 }
NamedImport ::= IDENTIFIER (as IDENTIFIER)?
{ recoverWhile = NamedImport_recover }
private NamedImport_recover ::= !(',' | '}')
FromClause ::= from ModuleSpecifier

ModuleSpecifier ::= STRING_LITERAL

// Output
VerboseOutputStatement ::= output Expression
ShortOutputStatement ::= '{' Expression '}'

// Void
VerboseVoidStatement ::= void Expression
{ pin = 1 }
ShortVoidStatement ::= '?' Expression

// Super
SuperStatement ::= super

// Throw
ThrowStatement ::= throw Expression

// Doctype
DoctypeStatement ::= doctype IDENTIFIER?

// Decorator
DecoratorStatement ::= ExecutionQualifiedIdentifier '(' ')'

// Template
TemplateHeadStatement ::= async? TemplateType '*'? DefinitionQualifiedIdentifier TemplateDeclarationTail?
{ pin = 2 }
TemplateDeclarationTail ::= Arguments TemplateInheritance?
TemplateInheritance ::= extends QualifiedIdentifier
TemplateType ::= template | interface | placeholder

// Blocks
BlockStatement ::= BlockHeadStatement EOS BlockBody?
BlockHeadStatement ::= block IDENTIFIER BlockHeadTail?
{ pin = 1; recoverWhile = Statement_recover }

ExternalBlockHeadStatement ::= block IDENTIFIER '->' IDENTIFIER BlockHeadTail?
{ pin = 1 }
BlockHeadTail ::= Arguments BlockSelfCall?
BlockSelfCall ::=  ('=>' Expression)

// Eval&Head
HeadOrEvalHeadStatement ::= eval | head

// Conditionals
ConditionalStatement ::= MainConditionalStatement SecondaryConditionalStatement*
MainConditionalStatement ::= MainConditionalHead EOS BlockBody?
MainConditionalHead ::= (if | unless) Expression
{ pin = 1; recoverWhile = Statement_recover }
SecondaryConditionalStatement ::= StatementStart SecondaryConditionalHead EOS BlockBody?
{ pin = 1 }
SecondaryConditionalHead ::= else SecondaryConditionalHeadTail?
{ pin = 1; recoverWhile = Statement_recover }
SecondaryConditionalHeadTail ::= (if | unless) Expression

SwitchStatement ::= switch Expression EOS SwitchBlockBody?
SwitchBlockBody ::= INDENT CaseStatement+ DefaultCaseStatement? DEDENT
CaseStatement ::= (StatementStart case | '>') Expression EOS BlockBody?
DefaultCaseStatement ::= StatementStart default EOS BlockBody?

// Loops
LoopStatement ::= ForLoopStatement
	| ForInLoopStatement
	| WhileLoopStatement
	| DoWhileLoopStatement

ForLoopStatement ::= for Expression ';' Expression ';' Expression EOS LoopBlockBody?
ForInLoopStatement ::= for (var | const | global | ':' | '-') IDENTIFIER in Expression EOS LoopBlockBody?
WhileLoopStatement ::= while Expression EOS LoopBlockBody?
DoWhileLoopStatement ::= do EOS LoopBlockBody? (StatementStart while EOS)?

LoopBlockBody ::= INDENT LoopBodyStatement+ DEDENT
LoopBodyStatement ::= BodyStatement | LoopControlStatement
LoopControlStatement ::= StatementStart (break | continue)

// Iterators
IteratorStatement ::= (FOREACH | FORIN) Expression '=>' Parameters EOS LoopBlockBody?

// try/catch/finally
TryCatchStatement ::= TryStatement CatchFinallyStatemnt?
TryStatement ::= try EOS BlockBody?
CatchFinallyStatemnt ::= CatchStatement FinallyStatement?
CatchStatement ::= StatementStart catch IDENTIFIER EOS BlockBody?
FinallyStatement ::= StatementStart finally EOS BlockBody?

// Function
FuncStatement ::= FuncDeclaration EOS BlockBody?
FuncDeclaration ::= func ArgumentDeclarationsList? | '(' ')' ['=>' ArgumentDeclarationsList?]

// Target
TargetStatement ::= target Expression (as IDENTIFIER)? EOS TargetBlockBody?
TargetBlockBody ::= INDENT CallBodyStatement+ DEDENT

// PutIn
VerbosePutInStatement ::= var? PUT_IN QualifiedIdentifier? EOS BlockBody?
ShortPutInStatement ::= ':' PUT_IN QualifiedIdentifier? EOS BlockBody?
SuperShortPutInStatement ::= '*' QualifiedIdentifier? EOS BlockBody?

// Call
VerboseCallStatement ::= call Expression EOS CallBlockBody?
ShortCallStatement ::= '+=' Expression EOS CallBlockBody?
CallBlockBody ::= INDENT CallBodyStatement+ DEDENT
CallBodyStatement ::= SuperShortPutInStatement | BodyStatement

// Return
ReturnStatement ::= return Expression? EOS BlockBody?

// With
WithStatement ::= with Expression EOS BlockBody?

// Tags
TagStatement ::= tag XmlTagDeclaration? XmlSelector? XmlAttrsDeclaration? EOS BlockBody?

// Parameters
Parameters ::= ParameterDeclaration (',' ParameterDeclaration)*
ParameterDeclaration ::= IDENTIFIER

// Arguments
Arguments ::= '(' ArgumentDeclarationsList? ')'
{ pin = 1 }
ArgumentDeclarationsList ::= ArgumentDeclaration (ArgumentDeclarationsListTail)*
ArgumentDeclarationsListTail ::= ',' ArgumentDeclaration
{ pin = 1 }
ArgumentDeclaration ::= IdentifierOrWithIdentifier ('?' | '!')? ('=' Expression)?
{ recoverWhile = ArgumentDeclaration_recover }
private ArgumentDeclaration_recover ::= !(')' | ',' | EOS)

// Qualified identifiers
// For template inheritance
QualifiedIdentifier ::= (IdentifierOrWithIdentifier | '[' Expression ']' | '@[' Expression ']') QualifiedIdentifierTail*
// For namespace and template definition
DefinitionQualifiedIdentifier ::= (IDENTIFIER | '[' Expression ']') QualifiedIdentifierTail*
// For template execution
ExecutionQualifiedIdentifier ::= (IdentifierOrWithIdentifier | '@[' Expression ']') QualifiedIdentifierTail*
QualifiedIdentifierTail ::= '.' IDENTIFIER | '[' Expression ']'

StatementStart ::= SHARP | MINUS

// XML
XmlStatement ::= TagDeclarationStart XmlTagDeclaration? XmlSelector? XmlAttrsDeclaration? EOS BlockBody?
XmlTagDeclaration ::= TAG_NAME | '?'
XmlSelector ::= CLASS_SELECTOR* ID_SELECTOR? CLASS_SELECTOR*
XmlAttrsDeclaration ::= XmlAttrDeclaration ('|' XmlAttrDeclaration)*
XmlAttrDeclaration ::= ATTR_NAME ['=' ATTR_VALUE?]

TagDeclarationStart ::= LT

// Template text
TemplateTextStatement ::= TEMPLATE_TEXT? (TemplateInclusion TEMPLATE_TEXT?)* EOS
TemplateInclusion ::= TemplateOutputStatement | TemplateInterpolationStatement
TemplateOutputStatement ::= '{' Expression '}'
TemplateInterpolationStatement ::= '{{' TEMPLATE_INTERPOLATION '}}'

// Expressions
Expression ::= AssignmentExpression
	| RelationExpression
	| EqualityExpression
	| AddGroup
	| BooleanGroup
	| MulGroup
	| UnaryGroup
	| TernaryExpression
	| MemberExpression

AssignmentExpression ::= Expression '=' Expression { rightAssociative=true }

RelationExpression ::= Expression RelationOperators Expression
RelationOperators ::= '<' | '>' | '<=' | '>='

EqualityExpression ::= Expression EqualityOperators Expression
EqualityOperators ::= '==' | '!=' | '===' | '!=='

private AddGroup ::= PlusExpression | MinusExpression
private BooleanGroup ::= IsNotExpression | XorExpression | AndExpression | OrExpression
private MulGroup ::= MulExpression | DivExpression | RemainderExpression
private UnaryGroup ::= UnaryPlusExpression | UnaryMinusExpression
private PrimaryGroup ::= LiteralExpression
	| ArrayLiteralExpression
	| ObjectLiteralExpression
	| ParenthesesExpression
	| IdentifierGroup

PlusExpression ::= Expression '+' Expression
MinusExpression ::= Expression '-' Expression

IsNotExpression ::= '!' Expression
XorExpression ::= Expression '^' Expression
AndExpression ::= Expression '&&' Expression
OrExpression ::= Expression '||' Expression

MulExpression ::= Expression '*' Expression
DivExpression ::= Expression '/' Expression
RemainderExpression ::= Expression '%' Expression

UnaryPlusExpression ::= '+' Expression
UnaryMinusExpression ::= '-' Expression

LiteralExpression ::= NULL_LITERAL
	| UNDEFINED_LITERAL
	| BOOLEAN_LITERAL
	| STRING_LITERAL
	| NUMERIC_LITERAL

IdentifierGroup ::= GLOBAL_IDENTIFIER
 | '@@[' Expression ']'
 | WITH_IDENTIFIER
 | '@[' Expression ']'
 | IDENTIFIER
IdentifierOrWithIdentifier ::= IDENTIFIER | WITH_IDENTIFIER

ArrayLiteralExpression ::= '[' ElementsList ']'
ElementsList ::= Expression (',' Expression)*

ObjectLiteralExpression ::= '{' PropertyAssignment '}'
PropertyAssignment ::= PropertyName ':' Expression
PropertyName ::= IDENTIFIER | STRING_LITERAL | NUMERIC_LITERAL

ParenthesesExpression ::= '(' Expression ')'

MemberExpression ::= PrimaryGroup MemberExpressionTail?
MemberExpressionTail ::= ('[' Expression ']' | '.' IDENTIFIER | CallArguments) MemberExpressionTail?
CallArguments ::= '(' [Expression (',' Expression)*] ')'

TernaryExpression ::= Expression '?' Expression ':' Expression
